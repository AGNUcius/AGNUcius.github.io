<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
  <title>thread  </title>
  <link href=".code/preferred.css" rel="stylesheet" type="text/css"/>
</head>

<body>
<p class='header'>
<a href="_home.htm">Home</a> | <a href="_faq.htm">FAQ</a> | <a href="_thesis.htm">Thesis</a> | <a href="_diary.htm">Diary</a> | <a href="_projects.htm">Projects</a> | <a href="resume.htm">Resume</a> | <a href="_todo.htm">Todo</a> | <a href="_index.htm">Index</a> |<p>
<p class='main'><span class="rel">Related:</span> cloth, con<a href="curr.htm">curr</a>ent, CPU, fiber, memory, process, schedule<br/>
<br/>
<a class="ext" href="http://TinyThreadLib.sf.net">TinyThreadLib.sf.net</a> <span class="quot2">>>Tiny<a href="thread.htm">Thread</a><a href="lib.htm">Lib</a> is a very lightweight C++ <a href="thread.htm">thread</a> <a href="lib.htm">lib</a>rary which acts as a wrapper around either p<a href="thread.htm">thread</a>s or the analogous Win32 API functions to provide classes for <a href="thread.htm">thread</a>s and <a href="sync.htm">sync</a>hronization <a href="obj.htm">obj</a>ects for multi<a href="thread.htm">thread</a>ed programming.</span><br/>
<br/>
<a class="ext" href="http://www.CodeProject.com/KB/cpp/FastDelegate.aspx">www.CodeProject.com/KB/cpp/FastDelegate.aspx</a> <span class="quot2">>>Standard C++ does not have true <a href="obj.htm">obj</a>ect-oriented function pointers. This is unfortunate, because <a href="obj.htm">obj</a>ect-oriented function pointers, also called 'closures' or 'delegates', have proved their value in similar languages. In Delphi <small>(<a href="obj.htm">Obj</a>ect Pascal)</small>, they are the basis for Bor<a href="land.htm">land</a>'s Visual Component <a href="lib.htm">Lib</a>rary <small>(VCL)</small>. More recently, C# has <a href="pop.htm">pop</a>ularized the delegate concept, contributing to the success of that language. For many applications, delegates simplify the <a href="use.htm">use</a> of elegant design patterns <small>(Observer, Strategy, <a href="stat.htm">Stat</a>e<small>[GoF]</small>)</small> composed of very loosely coupled <a href="obj.htm">obj</a>ects. There can be no doubt that such a feature would be <a href="use.htm">use</a>ful in standard C++.</span><br/>
<br/>
<a class="ext" href="http://Flounder.com/fibers.htm">Flounder.com/fibers.htm</a> <span class="quot2">>>This project <a href="cam.htm">cam</a>e about when I encountered a client that needed a fiber scheduler.&nbsp;&nbsp;The problem arose because of a need to convert non-<a href="preemptive.htm">preemptive</a> "<a href="thread.htm">thread</a>s" from an existing programming domain to Windows.&nbsp;&nbsp;<small>[This was <a href="part.htm">part</a> of my teaching, not <a href="part.htm">part</a> of a contract, and I presented this solution in class; therefore I was not actually paid to write it, and it remains mine.&nbsp;&nbsp;Just so you <a href="know.htm">know</a> that this wasn't <a href="prop.htm">prop</a>rietary <a href="work.htm">work</a>.]</small></span><br/>
<br/>
<a class="ext" href="http://XMailServer.org/libpcl.html">XMailServer.org/libpcl.html</a> <span class="quot2">>>The Portable Coroutine <a href="lib.htm">Lib</a>rary <small>(PCL)</small> implements the low level functionality for coroutines. For a definition of the term coroutine see The <a href="art.htm">Art</a> of <a href="compu.htm">Compu</a>ter Programming by Donald E. Knuth. Coroutines are a very simple cooperative multitasking environment where the switch from one task to another is done explicitly by a function call. Coroutines are a lot faster than processes or <a href="thread.htm">thread</a>s switch, since there is no OS kernel involvement for the operation. Also coroutines require much less OS re<a href="sourc.htm">sourc</a>es than processes of <a href="thread.htm">thread</a>s. The <a href="ide.htm">ide</a>a of writing this <a href="lib.htm">lib</a>rary <a href="start.htm">start</a>ed when I was testing Linux epoll functionality and performance. I initially <a href="start.htm">start</a>ed using the coro <a href="lib.htm">lib</a>rary by E. Toernig &lt;froese@<a class="ext" href="http://gmx.de">gmx.de</a>> and I found the <a href="lib.htm">lib</a>rary very interesting. It was simple and yet powerful. The limitations of the coro <a href="lib.htm">lib</a>rary were both non portability and crashes when not <a href="use.htm">use</a>d together with certain versions of gcc. So I decided to write a <a href="new.htm">new</a> <a href="lib.htm">lib</a>rary to address the problems aforementioned by also taking portable context switching <a href="ide.htm">ide</a>as from the <a href="gnu.htm">GNU</a> Pth <a href="lib.htm">lib</a>rary. This <a href="lib.htm">lib</a>rary is easily portable on almost every Unix system and on Windows. It can <a href="use.htm">use</a> either the ucontext.h functionalities <small>( getcontext<small>()</small>/<a href="mak.htm">mak</a><a href="econ.htm">econ</a>test<small>()</small>/swapcontext<small>()</small> )</small> or the standard longjmp<small>()</small>/setjmp<small>()</small>.</span><br/>
<br/>
<a class="ext" href="http://www.SEAS.UPenn.edu/~lipeng/homepage/unify.html">www.SEAS.UPenn.edu/~lipeng/homepage/unify.html</a> <span class="quot2">>>This project <a href="use.htm">use</a>s a language-based technique to unify two seemingly opposite programming <a href="mod.htm">mod</a>els for <a href="buil.htm">buil</a>ding massively con<a href="curr.htm">curr</a>ent <a href="net.htm">net</a><a href="work.htm">work</a> services: the event-driven <a href="mod.htm">mod</a>el and the multi<a href="thread.htm">thread</a>ed <a href="mod.htm">mod</a>el.&nbsp;&nbsp;The result is a unified con<a href="curr.htm">curr</a>ency <a href="mod.htm">mod</a>el providing both <a href="thread.htm">thread</a> abstractions and event abstractions.&nbsp;&nbsp;We implemented the unified con<a href="curr.htm">curr</a>ency <a href="mod.htm">mod</a>el in Haskell, a pure, lazy, functional programming language. Our implementation demonstrates how to <a href="use.htm">use</a> these techniques by <a href="buil.htm">buil</a>ding an application-level <a href="thread.htm">thread</a> <a href="lib.htm">lib</a>rary with support for multiprocessing and a<a href="sync.htm">sync</a>hronous I/O mechanisms in Linux.&nbsp;&nbsp;The <a href="thread.htm">thread</a> <a href="lib.htm">lib</a>rary is type-safe, is relatively simple to implement, and has good performance.&nbsp;&nbsp;Application-level <a href="thread.htm">thread</a>s are extremely lightweight <small>(scaling to 10,000,000 <a href="thread.htm">thread</a>s!)</small> and our scheduler, which is implemented as a <a href="mod.htm">mod</a>ular and extensible event-driven system, outperforms NPTL in I/O benchmarks.</span><br/>
<br/>
<a class="ext" href="http://State-Threads.sf.net">State-Threads.sf.net</a> <span class="quot2">>>The <a href="stat.htm">Stat</a>e <a href="thread.htm">Thread</a>s <a href="lib.htm">Lib</a>rary is a small application <a href="lib.htm">lib</a>rary which provides a foundation for writing fast and highly scalable Internet applications <small>(such as <a href="web.htm">web</a> servers, proxy servers, <a href="mail.htm">mail</a> transfer agents, and so on, <a href="real.htm">real</a>ly any <a href="net.htm">net</a><a href="work.htm">work</a>-data-driven application)</small> on UNIX-like platforms. It combines the simplicity of the multi<a href="thread.htm">thread</a>ed programming paradigm, in which one <a href="thread.htm">thread</a> supports each simultaneous connection, with the performance and scalability of an event-driven <a href="stat.htm">stat</a>e <a href="mac.htm">mac</a>hine architecture. In other words, this <a href="lib.htm">lib</a>rary offers a <a href="thread.htm">thread</a>ing API for structuring an Internet application as a <a href="stat.htm">stat</a>e <a href="mac.htm">mac</a>hine.</span><br/>
<br/>
<a class="ext" href="http://LinuxInsight.com/files/downey05semaphores.pdf">LinuxInsight.com/files/downey05semaphores.pdf</a> <span class="quot2">>>The Little Book of Semaphores is a <a href="free.htm">free</a> <small>(in both senses of the word)</small> textbook that introduces the principles of <a href="sync.htm">sync</a>hronization for con<a href="curr.htm">curr</a>ent programming.</span><br/>
<br/>
<a class="ext" href="http://liboop.OFB.net">liboop.OFB.net</a> <span class="quot2">>><a href="lib.htm">Lib</a>oop is a low-level event loop management <a href="lib.htm">lib</a>rary for POSIX-based <a href="operating system.htm">operating system</a>s. It supports the development of <a href="mod.htm">mod</a>ular, multiplexed applications which may respond to events from several <a href="sourc.htm">sourc</a>es. It replaces the "select<small>()</small> loop" and allows the registration of event handlers for <a href="file.htm">file</a> and <a href="net.htm">net</a><a href="work.htm">work</a> I/O, timers and signals. Since processes <a href="use.htm">use</a> these mechanisms for almost all external communication, <a href="lib.htm">lib</a>oop can be <a href="use.htm">use</a>d as the basis for almost any application.</span><br/>
<br/>
<a class="ext" href="http://Monkey.org/~provos/libevent">Monkey.org/~provos/libevent</a> <span class="quot2">>>The <a href="lib.htm">lib</a>event API provides a mechanism to execute a call<a href="back.htm">back</a> function when a specific event occurs on a <a href="file.htm">file</a> descriptor or after a timeout has been reached. Furthermore, <a href="lib.htm">lib</a>event also support call<a href="back.htm">back</a>s due to signals or regular timeouts.&nbsp;&nbsp;<a href="lib.htm">lib</a>event is meant to replace the event loop found in event driven <a href="net.htm">net</a><a href="work.htm">work</a> servers. An application just needs to call event_dispatch<small>()</small> and then add or remove events dynamically without having to change the event loop.</span><br/>
<br/>
<a class="ext" href="http://Kegel.com/c10k.html">Kegel.com/c10k.html</a> <span class="quot2">>>It's time for <a href="web.htm">web</a> servers to handle ten thousand clients simultaneously, don't you think? After all, the <a href="web.htm">web</a> is a big place now.</span><br/>
<br/>
<a class="ext" href="http://Tenermerx.com/Asio">Tenermerx.com/Asio</a> <span class="quot2">>>Asio is a cross-platform C++ <a href="lib.htm">lib</a>rary for <a href="net.htm">net</a><a href="work.htm">work</a> and low-level I/O programming that provides developers with a consistent a<a href="sync.htm">sync</a>hronous <a href="mod.htm">mod</a>el using a <a href="mod.htm">mod</a>ern C++ approach.</span><br/>
<br/>
<a class="ext" href="http://www.cs.wustl.edu/~schmidt/ACE.html">http://www.cs.wustl.edu/~schmidt/ACE.html</a> Is an older version of ASIO<br/>
<br/>
<a class="ext" href="http://ZThreads.sf.net">ZThreads.sf.net</a> <span class="quot2">>>A platform-independent, multi-<a href="thread.htm">thread</a>ing and <a href="sync.htm">sync</a>hronization <a href="lib.htm">lib</a>rary for C++</span><br/>
<br/>
<a class="ext" href="http://NPTLTraceTool.sf.net">NPTLTraceTool.sf.net</a> <span class="quot2">>>The POSIX <a href="thread.htm">Thread</a> Trace Toolkit <small>(PTT)</small> is a <a href="lib.htm">lib</a>rary-level trace tool for. the glibc <small>(<a href="gnu.htm">GNU</a> C <a href="lib.htm">lib</a>rary)</small> <a href="thread.htm">thread</a> <a href="lib.htm">lib</a>rary <small>(Native POSIX <a href="thread.htm">Thread</a> <a href="lib.htm">Lib</a>rary or NPTL)</small>. It aims to help <a href="user.htm">user</a>s to analyze and debug multi-<a href="thread.htm">thread</a>ed applications using the NPTL under Linux systems.</span><br/>
<br/>
<a class="ext" href="http://SICS.se/~adam/pt">SICS.se/~adam/pt</a> <span class="quot2">>>Proto<a href="thread.htm">thread</a>s are extremely lightweight stackless <a href="thread.htm">thread</a>s designed for severely memory constrained systems, such as small embedded systems or wireless sensor <a href="net.htm">net</a><a href="work.htm">work</a> nodes. Proto<a href="thread.htm">thread</a>s provide linear code execution for event-driven systems implemented in C. Proto<a href="thread.htm">thread</a>s can be <a href="use.htm">use</a>d with or without an underlying <a href="operating system.htm">operating system</a> to provide blocking event-handlers. Proto<a href="thread.htm">thread</a>s provide sequential flow of control without complex <a href="stat.htm">stat</a>e <a href="mac.htm">mac</a>hines or full multi-<a href="thread.htm">thread</a>ing.</span><br/>
<br/>
<a class="ext" href="http://And.org/texts/threads">And.org/texts/threads</a> <span class="quot2">>>When a lot of people speak about "multi-<a href="thread.htm">thread</a>ing" there is often this black and white view of the world where on one side you create mutliple <a href="thread.htm">thread</a>s that share all <a href="stat.htm">stat</a>e and <a href="use.htm">use</a> mutexes etc. and on the other every single instruction from your application to the device driver is completely <a href="sync.htm">sync</a>ronous.</span><br/>
</p>
<p class='footer'>
 Page generated from <a href=".text/thread">thread</a> by <a href=".code/etym.el">etym</a>.</p>
</body>
</html>
